/*! \page prestart Prestartable application development How-To

Prestarting and lazy shutdown reduces the start-up time of an
application to zero: the application is able to show its GUI
immediately when requested. MeeGo Touch supports prestarting and lazy shutdown
of application services, that is, applications that are started by
calling \c launch() (or some other application-specific method) in their
D-Bus interface.

Prestarted applications are started to a special \b prestarted \b
state during boot by a daemon called \b Applifed. In that state they are running
in the background in their mainloop but not showing nor doing anything. If
application gets terminated, Applifed re-prestarts is automatically.

A special type of prestarting, called "Lazy shutdown" allows an application 
to resume the \b prestarted \b state instead of terminating. This makes the next
application start-up very fast. Automatically prestarted applications
can use lazy shutdown as well.


\section terminology Terminology

- \b Launch - user action that aims to start an application so that
  its UI is shown (tapping the application icon, for instance).

- \b LazyShutdown and \b LazyShutdownMultiWindow - prestart modes in
  which an application process returns from the running state to the
  prestarted state when it is closed by the user or by the \c close()
  method in the D-Bus interface.

- \b Prestarted \b state - the state where an application waits for
  launching. In user point of view the application is not running, but
  it can be started up (switched to the running state) much faster
  than executing it from scratch. Attempts to show a window in this
  state are suppressed.

- \b Prestart \b mode - the property of an application that defines
  what happens to the application when it is closed. If not set,
  application does not support prestarting.

- \b Running \b state - the state where an application is running in
  the user point of view.

- \b TerminateOnClose and \b TerminateOnCloseMultiWindow- prestart
  modes in which an application process is terminated when the
  application is closed by the user or by the \c close() method in the
  D-Bus interface.


\section prestarting Prestarting an application

If an application supports prestarting, it must set the prestart mode
with \c MApplication::setPrestartMode(), regardless of the
commandline parameters and before using any other parts of the
prestarting API. A recommended place to do this is during or right
after instantiating the \c MApplication class.

Example:

\code
// example.cpp
// Minimal prestartable and lazy shutdownable application

#include <MApplication>
#include <MApplicationWindow>

int main(int argc, char ** argv)
{
    MApplication app(argc, argv);
    MApplication::setPrestartMode(M::LazyShutdown);

    MApplicationWindow window;
    window.show();

    return app.exec();
}
\endcode

Start the application to the prestarted state as follows.

\code
$ ./example -prestart &
\endcode

An application enters the prestarted state if it is started with the
\c -prestart commandline argument \b and it sets the prestart mode
before showing any windows. If either one of these conditions does not
hold, the application will enter to the running state.

The \c MApplicationWindow::show() method can be called even if the
application is in the prestarted state. The window will not become
visible to the user until the application is launched.

\c MApplication::isPrestarted() can be used to check if the
application is currently in the prestarted state.


\section launching Releasing application from the prestarted state

If the \c launch() method in MApplication's D-Bus interface is called
(because of user tapping the application icon, for instance) and the
application is in the prestarted state, the application is released
from the prestarted state and allowed to continue to the running
state. 

The default launch from the application grid can be simulated, for example, like this:

\code
$ dbus-send --dest=com.nokia.example --type="method_call" /org/maemo/m com.nokia.MApplicationIf.launch
\endcode

The application can also be released from the prestarted state in the code by calling
\c MApplication::setPrestarted(false). This is equivalent to the D-Bus \c launch().

The application can react to the launch by connecting the \c
MApplication::prestartReleased() signal, or by overriding
MApplication::releasePrestart() handler. The default handler shows
the active application window of a single-window application, if there
is such a thing.

For multiwindow applications the default handler does nothing. They
must explicitely release the application from the prestarted by
calling \c MApplication::setPrestarted(false) and show the window
after that. 


\section lazyshutdown Returning to the prestarted state

An application returns from the running state to the prestarted state
if its prestarted mode is set to \c M::LazyShutdown or \c
M::LazyShutdownMultiWindow and its last window is closed.

The application can react to restoring the prestarted state by
connecting to the \c MApplication::prestartRestored() signal, or by
overriding the \c MApplication::restorePrestart() event handler. 
The default implementation of \c MApplication::restorePrestart() hides all the open windows.

The application can also return to the prestarted state in the code by calling
\c MApplication::setPrestarted(true). This is will effectively call the 
\c MApplication::restorePrestart() event handler if one of the lazy shutdown
modes is set. 


\section automaticprestart Prestarting during boot and enabling lazy shutdown

In order to enable lazy shutdown of the application or make the
application prestartable during device boot, \c -prestart must be
added to the \b .service \b-file of the application:

\code
[D-BUS Service]
Name=com.nokia.example
Exec=/usr/bin/example -prestart
\endcode

Note: modifying the service file will not cause starting up and prestarting the
application at boot, it only makes it possible.

If \b Applifed is used for prestarting applications at boot, its configuration file is located in \c
/etc/prestart. This file contains the names of the prestartable D-Bus services and the
prestarting priority among some other things, like CPU-load thresholds.

Boot time prestart configuration is typically part of
platform-specific configurations, and is \b not provided in application
packages.


\section killing Sudden deaths in the prestarted state

Applications in the prestarted state never interact with the user.
Neither should they take care of any critical tasks, because whether
or not the applications will be prestarted at all is up to the
configuration politics.

These facts make the applications in the prestarted state as number
one candidates for suspending and killing when the system resources
run low. Therefore, application developers must be aware that an
application in the prestarted state may be killed with KILL signal at
any time without any warning.


\section multiwindow Prestarting multiwindow applications

Multi-window applications can be prestarted by using
LazyShutdownMultiWindow and TerminateOnCloseMultiWindow modes. The
difference to the single-window applications is that no window is
shown by default when the launch() method is called from the D-Bus
interface. The window should be shown by the code that handles the
D-Bus call, and the code should release the application from the
prestarted state before that. See the following example:

\code
void MultiWindowApplication::activateWindow(int index)
{
    // This is the real handler for D-Bus method activateWindow(int)
    // that shows a window (and page) of the given index. 

    if (index >= 0 && index < NUM_WINDOWS)  {

        // Force release from prestart if in prestarted state.
        // This is important, because it sets the internal state.
        if (isPrestarted()) {
            setPrestarted(false);
        }

        // Show the desired window
        m_window[index]->show();
        m_window[index]->activateWindow();
        m_window[index]->raise();

        // Show the page and activate it
        m_mainPage[index]->appear();
        m_mainPage[index]->activateWidgets();
    }
}
\endcode

A multi-window application enters the prestarted state when all of its
windows are closed. The cleanup for the closed windows can be done, for
instance, on the closeEvent handler of each window, or on restoring
the prestarted state when all windows are closed.


\section windowclose Controlling window closing on lazy shutdown

The default behavior on window close varies depending on the prestart
mode. On LazyShutdown and LazyShutdownMultiWindow windows are hidden
by default. On TerminateOnClose and TerminateOnCloseMultWindow windows
are really closed, just like when application has not been prestarted.

The default closing behavior can changed by overriding the closeEvent
handler of the window and using \c
MWindow::setCloseOnLazyShutdown. This is demonstrated in the
following example.

\code
#include <MApplication>
#include <MApplicationWindow>
#include <MApplicationPage>
#include <MComboBox>
#include <MDebug>
#include <QStringList>

class MyWindow : public MApplicationWindow
{
public:
    MyWindow();

protected:
    virtual void closeEvent(QCloseEvent *event);

private:
    MApplicationPage *page;
    MComboBox *comboBox;
};

MyWindow::MyWindow() 
{
    page = new MApplicationPage();
    page->setTitle("closeEvent example app");
    comboBox = new MComboBox();
    comboBox->setTitle("What should closeEvent do?");
    QStringList stringList;
    stringList << "Ignore closeEvent" << "Hide window (LazyShutdown)" << "Really close window";
    comboBox->addItems(stringList);
    page->setCentralWidget(comboBox);
    page->appear();
}

void MyWindow::closeEvent(QCloseEvent *event)
{
    switch (comboBox->currentIndex()) {
    case 0: 
        mDebug("MyWindow") << "Ignore closeEvent(). Window is not closed.";
        event->ignore(); 
        break;
    case 1: 
        mDebug("MyWindow") << "Lazy shutdown - hide the window";
        setCloseOnLazyShutdown(false);
        event->accept(); 
        break;
    case 2:
    default: 
        mDebug("MyWindow") << "Lazy shutdown - really close the window";
        setCloseOnLazyShutdown(true);
        event->accept(); 
        break;
    }
}

int main(int argc, char **argv)
{
    MApplication app(argc, argv);
    MApplication::setPrestartMode(M::LazyShutdown);

    MyWindow *window = new MyWindow();
    window->show();
 
    return app.exec();
}
\endcode


\section example Example on using handlers

The following example presents a skeleton of a single window
application. If application is started with the \c -prestart
commandline argument, it connects the signal about restoring the
prestarted state to the slot that resets the page displayed on the
window. Note that showing and hiding the window does not require any
actions from the application developer in the single window
applications (see the default event handlers above).


\code

// More complex LazyShutdown example using signals.
// Using M::TerminateOnClose is just as simple, you'd just
// set that mode without handling any prestart
// restores or resets.

class MainPage: public MApplicationPage 
{
public slots:
    // Activate widgets here
    void activateWidgets();

    // Deactivate widgets and reset state
    void resetState();
};

int main(int argc, char ** argv)
{
    MApplication app(argc, argv);
    MApplication::setPrestartMode(M::LazyShutdown);

    MApplicationWindow window;
    window.show();

    MainPage mainPage;
    mainPage.appear();

    // Reset the state of the page shown on the window
    // when application returns from the running state
    // to the prestarted state
    app.connect(&app, SIGNAL(prestartRestored()), 
                &mainPage, SLOT(resetState()));

    // Activate widgets when released from the prestarted state
    app.connect(&app, SIGNAL(prestartReleased()), 
                &mainPage, SLOT(activateWidgets()));

    // Check if app is NOT in the prestarted state. This might
    // happen for example if the application is launched from the 
    // application grid before Applifed has prestarted it or if it's
    // started without -prestart.

    if (!app.isPrestarted()) {
        // Activate widgets now
        mainPage.activateWidgets();
    }

    return app.exec();
}
\endcode

\code

// Example of an application that supports LazyShutdown -prestarting using virtual handlers 
// (cannot be compiled due to missing implementation for the example page):

class MyApplication : public MApplication
{
    Q_OBJECT

public:
    MyApplication(int argc, char ** argv);
    ~MyApplication();

    // Re-implementation
    virtual void releasePrestart();

    // Re-implementation
    virtual void restorePrestart();

private:

    // Main window
    MApplicationWindow * m_window;

    // MApplicationPage -derived page
    MainPage * m_page;
};

MyApplication::MyApplication(int argc, char ** argv) :
    MApplication(argc, argv)
{
    // Use the LazyShutdown mode
    setPrestartMode(M::LazyShutdown);

    m_window = new MApplicationWindow;
    m_window->show();

    m_page = new MApplicationPage;
    m_page->appear();

    // Run activateWidgets() here to setup things 
    // if app is NOT in the prestarted state, otherwise it 
    // will be called from the handler method.

    if (!isPrestarted()) {
        m_page->activateWidgets();
    }
}

void MyApplication::releasePrestart()
{
    // Your stuff here
    m_page->activateWidgets();

    // Call the default implementation to show the window.
    MApplication::releasePrestart();
}

void MyApplication::restorePrestart()
{
    // Your stuff here
    m_page->deactivateAndResetWidgets();

    // Call the default implementation to hide the window.
    MApplication::restorePrestart();
}

MyApplication::~MyApplication()
{
    delete m_window;
    delete m_page;
}

int main(int argc, char ** argv)
{
    MyApplication app(argc, argv);
    return app.exec();
}

\endcode

*/
